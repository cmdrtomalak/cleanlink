import UIKit
class LinkShareViewController: UIViewController {
    private let infoLabel = UILabel(); private let twitterLabel = UILabel(); private let genericLabel = UILabel(); private let copyPreferredButton = UIButton(type: .system); private let openAppButton = UIButton(type: .system); private var result: CleanResult?
    override func viewDidLoad() { super.viewDidLoad(); view.backgroundColor = .systemBackground; setupUI(); processInputItems() }
    private func setupUI() { infoLabel.text = "Cleaning shared link..."; [twitterLabel, genericLabel].forEach { $0.numberOfLines = 0; $0.font = .systemFont(ofSize: 13) }; copyPreferredButton.setTitle("Copy", for: .normal); openAppButton.setTitle("Open App", for: .normal); copyPreferredButton.addTarget(self, action: #selector(copyPreferred), for: .touchUpInside); openAppButton.addTarget(self, action: #selector(openApp), for: .touchUpInside); let stack = UIStackView(arrangedSubviews: [infoLabel, twitterLabel, genericLabel, copyPreferredButton, openAppButton]); stack.axis = .vertical; stack.spacing = 12; view.addSubview(stack); stack.translatesAutoresizingMaskIntoConstraints = false; NSLayoutConstraint.activate([stack.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 12), stack.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -12), stack.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 12)]) }
    private func processInputItems() { guard let items = extensionContext?.inputItems as? [NSExtensionItem] else { return }; for item in items { if let attachments = item.attachments { for provider in attachments { if provider.hasItemConformingToTypeIdentifier("public.url") { provider.loadItem(forTypeIdentifier: "public.url", options: nil) { data,_ in if let url = data as? URL { self.clean(url.absoluteString) } }; return } else if provider.hasItemConformingToTypeIdentifier("public.text") { provider.loadItem(forTypeIdentifier: "public.text", options: nil) { data,_ in if let text = data as? String { self.clean(text) } }; return } } } } }
    private func clean(_ raw: String) { DispatchQueue.main.async { if let res = LinkCleaner.clean(raw) { self.result = res; self.infoLabel.text = "Cleaned link"; self.twitterLabel.text = res.twitter == nil ? "" : "Twitter: \(res.twitter!)"; self.genericLabel.text = "Preferred: \(res.preferred)" } else { self.infoLabel.text = "Could not clean URL" } } }
    @objc private func copyPreferred() { guard let link = result?.preferred else { return }; UIPasteboard.general.string = link; infoLabel.text = "Copied!"; DispatchQueue.main.asyncAfter(deadline: .now() + 0.7) { self.finish() } }
    @objc private func openApp() { guard let link = result?.preferred, let encoded = link.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else { finish(); return }; let scheme = "cleanlink://?u=\(encoded)"; if let url = URL(string: scheme) { _ = self.openURL(url) }; finish() }
    private func openURL(_ url: URL) -> Bool { var r: UIResponder? = self; while r != nil { if let app = r as? UIApplication { app.perform(#selector(UIApplication.openURL(_:)), with: url); return true }; r = r?.next }; return false }
    private func finish() { extensionContext?.completeRequest(returningItems: nil, completionHandler: nil) }
}
